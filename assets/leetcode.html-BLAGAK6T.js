import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as r,o as e}from"./app-CYdqwrco.js";const a={};function o(i,t){return e(),n("div",null,[...t[0]||(t[0]=[r('<h2 id="常用算法思想" tabindex="-1"><a class="header-anchor" href="#常用算法思想"><span>常用算法思想</span></a></h2><table><thead><tr><th>算法思想</th><th>核心逻辑</th><th>典型应用场景</th><th>主要步骤</th></tr></thead><tbody><tr><td>暴力枚举 (Brute Force)</td><td>穷举所有可能，适合数据量小或无更优解法时使用</td><td>子集、全排列、简单模拟</td><td>列举所有可能 → 检查每种情况</td></tr><tr><td>递归 (Recursion)</td><td>问题自我调用自身，分解为更小子问题</td><td>树遍历、分治、回溯</td><td>设定终止条件 → 递归调用自身 → 合并结果</td></tr><tr><td>回溯 (Backtracking)</td><td>递归试探所有可能，遇到不合法就回退</td><td>组合、排列、N皇后、数独</td><td>尝试选择 → 递归探索 → 发现不行就回退（撤销选择）</td></tr><tr><td>分治（Divide &amp; Conquer）</td><td>拆解为子问题递归解决后合并结果</td><td>归并排序、快速排序、最近点对</td><td>拆分问题 → 递归求解 → 合并结果</td></tr><tr><td>双指针 (Two Pointers)</td><td>用两个指针遍历或扫描序列</td><td>区间、排序、去重、链表</td><td>指针初始化 → 同步/异步移动 → 满足条件时处理</td></tr><tr><td>滑动窗口 (Sliding Window)</td><td>维护一个区间窗口，动态调整窗口边界</td><td>子串/子数组、最短区间</td><td>扩大窗口 → 满足条件时收缩窗口 → 记录最优解</td></tr><tr><td>哈希 (Hashing)</td><td>用哈希表快速查找、去重、计数等</td><td>查重、计数、映射</td><td>构建哈希表 → 查找/插入/删除 → 处理冲突</td></tr><tr><td>栈/队列 (Stack/Queue)</td><td>先进后出/先进先出，辅助递归、遍历</td><td>括号匹配、层序遍历、单调栈</td><td>入栈/队 → 弹出/出队 → 处理元素</td></tr><tr><td>单调栈/队列 (Monotonic Stack/Queue)</td><td>维护单调性，区间最值</td><td>下一个更大元素、滑动窗口最大值</td><td>入栈/队时维护单调 → 弹出不符元素 → 记录答案</td></tr><tr><td>并查集 (Union Find)</td><td>处理集合合并与查询</td><td>连通性、分组、朋友圈</td><td>初始化集合 → 合并集合 → 查询根节点</td></tr><tr><td>拓扑排序 (Topological Sort)</td><td>有向无环图排序</td><td>任务调度、依赖关系</td><td>统计入度 → 队列弹出入度为0节点 → 更新入度</td></tr><tr><td>贪心（Greedy）</td><td>每一步选择局部最优</td><td>区间调度、最小生成树、跳跃游戏</td><td>按规则排序/选择 → 每步取最优 → 得到全局解</td></tr><tr><td>动态规划（DP）</td><td>分解为重叠子问题，递推求解</td><td>背包、最长子序列、股票买卖</td><td>定义状态 → 状态转移 → 递推填表</td></tr><tr><td>记忆化搜索 (Memoization)</td><td>递归+缓存子问题结果，避免重复计算</td><td>递归DP、树形DP</td><td>递归求解 → 查询/保存子问题结果 → 返回答案</td></tr><tr><td>二分查找 (Binary Search)</td><td>有序区间每次折半查找</td><td>有序数组、最值判定</td><td>设定左右边界 → 取中间值 → 判断调整区间</td></tr><tr><td>位运算 (Bit Manipulation)</td><td>用二进制位操作优化空间和速度</td><td>状态压缩、子集枚举</td><td>构造掩码 → 按位操作 → 组合/判断状态</td></tr><tr><td>树状数组/线段树 (BIT/Segment Tree)</td><td>区间查询与修改，适合动态数据结构</td><td>区间和、区间最值</td><td>构建树结构 → 查询/修改区间 → 递归/迭代更新</td></tr><tr><td>有限状态机（FSM）</td><td>定义状态和转移规则，按输入切换</td><td>KMP、正则表达式解析</td><td>设计状态 → 按输入转移 → 处理输出</td></tr><tr><td>随机化算法（Randomized）</td><td>利用随机性加速或近似求解</td><td>快速排序、素数测试</td><td>随机选择/采样 → 多次尝试 → 统计/判断</td></tr><tr><td>Meet in the Middle</td><td>分两半分别求解后合并结果</td><td>超大背包、子集和</td><td>拆分集合 → 分别枚举 → 合并统计</td></tr><tr><td>扫描线（Sweep Line）</td><td>按顺序扫描事件处理区间重叠</td><td>矩形面积并、航班统计</td><td>排序事件 → 顺序扫描 → 动态维护区间</td></tr><tr><td>启发式搜索（Heuristic）</td><td>用估价函数优先探索更优路径</td><td>A*、八数码、路径规划</td><td>设计估价函数 → 优先队列扩展 → 找到目标</td></tr><tr><td>模拟退火（Simulated Annealing）</td><td>概率性接受次优解跳出局部最优</td><td>TSP、参数优化</td><td>初始解 → 随机扰动 → 接受/拒绝新解</td></tr><tr><td>遗传算法（Genetic Algorithm）</td><td>模拟进化逼近最优解</td><td>组合优化、超参数调优</td><td>编码种群 → 选择/交叉/变异 → 迭代进化</td></tr></tbody></table><h2 id="数学与几何相关算法" tabindex="-1"><a class="header-anchor" href="#数学与几何相关算法"><span>数学与几何相关算法</span></a></h2><table><thead><tr><th>算法思想</th><th>核心逻辑</th><th>典型应用场景</th><th>主要步骤</th></tr></thead><tbody><tr><td>数论（Number Theory）</td><td>利用质数、模运算、同余等性质解决问题</td><td>RSA加密、约瑟夫环</td><td>分析性质 → 设计公式/递推 → 求解</td></tr><tr><td>计算几何（Computational Geometry）</td><td>向量、叉积等处理几何图形</td><td>凸包、最近点对、线段相交</td><td>坐标建模 → 几何运算 → 判断/统计</td></tr><tr><td>线性代数（Linear Algebra）</td><td>矩阵运算、特征值分解等高维问题</td><td>PCA、SVD、图像处理</td><td>构建矩阵 → 运算/分解 → 得到结果</td></tr></tbody></table><h2 id="字符串处理专项" tabindex="-1"><a class="header-anchor" href="#字符串处理专项"><span>字符串处理专项</span></a></h2><table><thead><tr><th>算法思想</th><th>核心逻辑</th><th>典型应用场景</th><th>主要步骤</th></tr></thead><tbody><tr><td>KMP算法</td><td>部分匹配表避免重复匹配</td><td>字符串模式匹配</td><td>构建next表 → 匹配时跳转 → 找到所有位置</td></tr><tr><td>Trie（前缀树）</td><td>树形结构存储字符串，共享前缀</td><td>自动补全、词频统计</td><td>构建树结构 → 插入/查找 → 统计/输出</td></tr><tr><td>后缀自动机（SAM）</td><td>压缩后缀信息高效处理子串</td><td>最长重复子串、子串计数</td><td>构建自动机 → 状态转移 → 统计答案</td></tr><tr><td>Rabin-Karp</td><td>滚动哈希快速比较子串</td><td>多模式匹配、查重</td><td>计算哈希 → 滑动窗口 → 比较/确认</td></tr></tbody></table><h2 id="图论进阶算法" tabindex="-1"><a class="header-anchor" href="#图论进阶算法"><span>图论进阶算法</span></a></h2><table><thead><tr><th>算法思想</th><th>核心逻辑</th><th>典型应用场景</th><th>主要步骤</th></tr></thead><tbody><tr><td>网络流（Network Flow）</td><td>建模为流量网络，求最大流/最小割</td><td>任务分配、二分图匹配</td><td>建图 → 增广路/推流 → 统计最大流</td></tr><tr><td>欧拉回路/路径</td><td>遍历所有边且不重复</td><td>邮路、DNA组装</td><td>统计度数 → DFS/栈遍历 → 记录路径</td></tr><tr><td>Tarjan算法</td><td>DFS求强连通分量、割点/桥</td><td>社区发现、电路设计</td><td>DFS遍历 → 记录时间戳 → 标记分量</td></tr><tr><td>匈牙利算法</td><td>增广路径求二分图最大匹配</td><td>任务分配、约会匹配</td><td>匹配初始化 → DFS/BFS增广 → 更新匹配</td></tr></tbody></table><h2 id="特殊场景优化算法" tabindex="-1"><a class="header-anchor" href="#特殊场景优化算法"><span>特殊场景优化算法</span></a></h2><table><thead><tr><th>算法思想</th><th>核心逻辑</th><th>典型应用场景</th><th>主要步骤</th></tr></thead><tbody><tr><td>离线算法（Offline）</td><td>预处理所有查询后统一处理</td><td>区间统计、莫队算法</td><td>收集所有查询 → 排序/分组 → 统一处理</td></tr><tr><td>增量算法（Incremental）</td><td>逐步添加数据动态维护结果</td><td>实时数据流处理</td><td>初始化结构 → 每次插入/更新 → 维护答案</td></tr><tr><td>近似算法（Approximation）</td><td>牺牲精度换取效率</td><td>NP难问题工程解法</td><td>设计近似规则 → 迭代优化 → 得到可行解</td></tr></tbody></table>',10)])])}const l=d(a,[["render",o]]),m=JSON.parse(`{"path":"/coding/leetcode.html","title":"A Quick Summary of Popular Algorithms in Leetcode","lang":"zh-CN","frontmatter":{"title":"A Quick Summary of Popular Algorithms in Leetcode","icon":"square-binary","description":"常用算法思想 数学与几何相关算法 字符串处理专项 图论进阶算法 特殊场景优化算法","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"A Quick Summary of Popular Algorithms in Leetcode\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-07T06:21:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dale\\",\\"url\\":\\"https://github.com/shyu216\\"}]}"],["meta",{"property":"og:url","content":"https://shyu216.github.io/knownoevil/knownoevil/coding/leetcode.html"}],["meta",{"property":"og:site_name","content":"SIHONG's Blog"}],["meta",{"property":"og:title","content":"A Quick Summary of Popular Algorithms in Leetcode"}],["meta",{"property":"og:description","content":"常用算法思想 数学与几何相关算法 字符串处理专项 图论进阶算法 特殊场景优化算法"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T06:21:45.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T06:21:45.000Z"}]]},"git":{"createdTime":1747214503000,"updatedTime":1767766905000,"contributors":[{"name":"shyu216","username":"shyu216","email":"yusihong073@gmail.com","commits":4,"url":"https://github.com/shyu216"}]},"readingTime":{"minutes":5.64,"words":1692},"filePathRelative":"coding/leetcode.md","excerpt":"<h2>常用算法思想</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>算法思想</th>\\n<th>核心逻辑</th>\\n<th>典型应用场景</th>\\n<th>主要步骤</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>暴力枚举 (Brute Force)</td>\\n<td>穷举所有可能，适合数据量小或无更优解法时使用</td>\\n<td>子集、全排列、简单模拟</td>\\n<td>列举所有可能 → 检查每种情况</td>\\n</tr>\\n<tr>\\n<td>递归 (Recursion)</td>\\n<td>问题自我调用自身，分解为更小子问题</td>\\n<td>树遍历、分治、回溯</td>\\n<td>设定终止条件 → 递归调用自身 → 合并结果</td>\\n</tr>\\n<tr>\\n<td>回溯 (Backtracking)</td>\\n<td>递归试探所有可能，遇到不合法就回退</td>\\n<td>组合、排列、N皇后、数独</td>\\n<td>尝试选择 → 递归探索 → 发现不行就回退（撤销选择）</td>\\n</tr>\\n<tr>\\n<td>分治（Divide &amp; Conquer）</td>\\n<td>拆解为子问题递归解决后合并结果</td>\\n<td>归并排序、快速排序、最近点对</td>\\n<td>拆分问题 → 递归求解 → 合并结果</td>\\n</tr>\\n<tr>\\n<td>双指针 (Two Pointers)</td>\\n<td>用两个指针遍历或扫描序列</td>\\n<td>区间、排序、去重、链表</td>\\n<td>指针初始化 → 同步/异步移动 → 满足条件时处理</td>\\n</tr>\\n<tr>\\n<td>滑动窗口 (Sliding Window)</td>\\n<td>维护一个区间窗口，动态调整窗口边界</td>\\n<td>子串/子数组、最短区间</td>\\n<td>扩大窗口 → 满足条件时收缩窗口 → 记录最优解</td>\\n</tr>\\n<tr>\\n<td>哈希 (Hashing)</td>\\n<td>用哈希表快速查找、去重、计数等</td>\\n<td>查重、计数、映射</td>\\n<td>构建哈希表 → 查找/插入/删除 → 处理冲突</td>\\n</tr>\\n<tr>\\n<td>栈/队列 (Stack/Queue)</td>\\n<td>先进后出/先进先出，辅助递归、遍历</td>\\n<td>括号匹配、层序遍历、单调栈</td>\\n<td>入栈/队 → 弹出/出队 → 处理元素</td>\\n</tr>\\n<tr>\\n<td>单调栈/队列 (Monotonic Stack/Queue)</td>\\n<td>维护单调性，区间最值</td>\\n<td>下一个更大元素、滑动窗口最大值</td>\\n<td>入栈/队时维护单调 → 弹出不符元素 → 记录答案</td>\\n</tr>\\n<tr>\\n<td>并查集 (Union Find)</td>\\n<td>处理集合合并与查询</td>\\n<td>连通性、分组、朋友圈</td>\\n<td>初始化集合 → 合并集合 → 查询根节点</td>\\n</tr>\\n<tr>\\n<td>拓扑排序 (Topological Sort)</td>\\n<td>有向无环图排序</td>\\n<td>任务调度、依赖关系</td>\\n<td>统计入度 → 队列弹出入度为0节点 → 更新入度</td>\\n</tr>\\n<tr>\\n<td>贪心（Greedy）</td>\\n<td>每一步选择局部最优</td>\\n<td>区间调度、最小生成树、跳跃游戏</td>\\n<td>按规则排序/选择 → 每步取最优 → 得到全局解</td>\\n</tr>\\n<tr>\\n<td>动态规划（DP）</td>\\n<td>分解为重叠子问题，递推求解</td>\\n<td>背包、最长子序列、股票买卖</td>\\n<td>定义状态 → 状态转移 → 递推填表</td>\\n</tr>\\n<tr>\\n<td>记忆化搜索 (Memoization)</td>\\n<td>递归+缓存子问题结果，避免重复计算</td>\\n<td>递归DP、树形DP</td>\\n<td>递归求解 → 查询/保存子问题结果 → 返回答案</td>\\n</tr>\\n<tr>\\n<td>二分查找 (Binary Search)</td>\\n<td>有序区间每次折半查找</td>\\n<td>有序数组、最值判定</td>\\n<td>设定左右边界 → 取中间值 → 判断调整区间</td>\\n</tr>\\n<tr>\\n<td>位运算 (Bit Manipulation)</td>\\n<td>用二进制位操作优化空间和速度</td>\\n<td>状态压缩、子集枚举</td>\\n<td>构造掩码 → 按位操作 → 组合/判断状态</td>\\n</tr>\\n<tr>\\n<td>树状数组/线段树 (BIT/Segment Tree)</td>\\n<td>区间查询与修改，适合动态数据结构</td>\\n<td>区间和、区间最值</td>\\n<td>构建树结构 → 查询/修改区间 → 递归/迭代更新</td>\\n</tr>\\n<tr>\\n<td>有限状态机（FSM）</td>\\n<td>定义状态和转移规则，按输入切换</td>\\n<td>KMP、正则表达式解析</td>\\n<td>设计状态 → 按输入转移 → 处理输出</td>\\n</tr>\\n<tr>\\n<td>随机化算法（Randomized）</td>\\n<td>利用随机性加速或近似求解</td>\\n<td>快速排序、素数测试</td>\\n<td>随机选择/采样 → 多次尝试 → 统计/判断</td>\\n</tr>\\n<tr>\\n<td>Meet in the Middle</td>\\n<td>分两半分别求解后合并结果</td>\\n<td>超大背包、子集和</td>\\n<td>拆分集合 → 分别枚举 → 合并统计</td>\\n</tr>\\n<tr>\\n<td>扫描线（Sweep Line）</td>\\n<td>按顺序扫描事件处理区间重叠</td>\\n<td>矩形面积并、航班统计</td>\\n<td>排序事件 → 顺序扫描 → 动态维护区间</td>\\n</tr>\\n<tr>\\n<td>启发式搜索（Heuristic）</td>\\n<td>用估价函数优先探索更优路径</td>\\n<td>A*、八数码、路径规划</td>\\n<td>设计估价函数 → 优先队列扩展 → 找到目标</td>\\n</tr>\\n<tr>\\n<td>模拟退火（Simulated Annealing）</td>\\n<td>概率性接受次优解跳出局部最优</td>\\n<td>TSP、参数优化</td>\\n<td>初始解 → 随机扰动 → 接受/拒绝新解</td>\\n</tr>\\n<tr>\\n<td>遗传算法（Genetic Algorithm）</td>\\n<td>模拟进化逼近最优解</td>\\n<td>组合优化、超参数调优</td>\\n<td>编码种群 → 选择/交叉/变异 → 迭代进化</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}`);export{l as comp,m as data};
